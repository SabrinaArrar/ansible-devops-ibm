# 1. Check manual public TLS certificate files is present in the certificate path.
# -----------------------------------------------------------------------------

- name: debug the vars
  debug:
    msg:
      - "app ........ {{ app_name }}"
      - "cert_path ........ {{ cert_path }}"

- name: "Check Public TLS tls.crt file is present in {{ cert_path }}"
  stat:
    path: "{{ cert_path }}/tls.crt"
  register: tls_crt_stat

- name: "Check Public TLS tls.key file is present in {{ cert_path }}"
  stat:
    path: "{{ cert_path }}/tls.key"
  register: tls_key_stat

- name: "Check Public CA ca.crt file is present in {{ cert_path }}"
  stat:
    path: "{{ cert_path }}/ca.crt"
  register: ca_crt_stat

- name: "Check if all mandatory certificate files are present."
  assert:
    that:
      - tls_crt_stat.stat.exists
      - tls_key_stat.stat.exists
      - ca_crt_stat.stat.exists
    fail_msg: "Public certificate TLS files 'tls.crt', 'tls.key' and 'ca.crt' should be present in {{ cert_path }}"

# 2. Create namespace we will deploy to
# -----------------------------------------------------------------------------
- name: "Create namespace"
  kubernetes.core.k8s:
    api_version: v1
    kind: Namespace
    name: "mas-{{ mas_instance_id }}-{{ app_name }}"


- name: "Create Public certificate secret in {{ app_name }} namespace when manual certificate management mode is turned on"
  kubernetes.core.k8s:
    definition:
      apiVersion: v1
      kind: Secret
      type: kubernetes.io/tls
      metadata:
        name: "{{ tlssecretname[app_name] }}"
        namespace: "mas-{{ mas_instance_id }}-{{ app_name }}"
      data:
        tls.key: "{{ lookup('file', '{{ cert_path }}/tls.key') | b64encode }}"
        tls.crt: "{{ lookup('file', '{{ cert_path }}/tls.crt') | b64encode }}"
        ca.crt: "{{ lookup('file', '{{ cert_path }}/ca.crt') | b64encode }}"
    wait: yes
    wait_timeout: 60 # subsequent tasks will fail if the group isn't fully created
